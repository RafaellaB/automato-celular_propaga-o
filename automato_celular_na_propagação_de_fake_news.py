# -*- coding: utf-8 -*-
"""automato celular na propagação de fake news.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ex_RblHlafhH6F_tdM0U9Di9EM_EM2NK
"""

import numpy as np
import matplotlib.pyplot as plt

# Definindo os tipos de células
FAKE = -1
NEUTRAL = 0
TRUTH = 1

# Inicialização da matriz do estado
CELL_SIZE = 40
dimensions = (100, 100)

# Inicialização da matriz com valores aleatórios
state_matrix = np.random.choice(a=[FAKE, NEUTRAL, TRUTH], size=dimensions, p=[0.235, 0.235, 0.53])

# Função que atualiza o estado das células
def update_cell(i, j, state_matrix):
    # Contando vizinhos
    neighbors = state_matrix[max(i-1, 0):i+2, max(j-1, 0):j+2]

    fake_neighbors = np.count_nonzero(neighbors == FAKE)
    truth_neighbors = np.count_nonzero(neighbors == TRUTH)
    neutral_neighbors = np.count_nonzero(neighbors == NEUTRAL)

    current_value = state_matrix[i, j]

    # Lógica para atualizar a célula
    if current_value == NEUTRAL:
        if fake_neighbors >= 4:
            return FAKE
        elif truth_neighbors >= 4:
            return TRUTH
        return NEUTRAL
    elif current_value == FAKE:
        if truth_neighbors >= 7:
            return TRUTH
        elif 5 <= truth_neighbors <= 6:
            return NEUTRAL
        return FAKE
    elif current_value == TRUTH:
        if fake_neighbors >= 7:
            return FAKE
        elif 5 <= fake_neighbors <= 6:
            return NEUTRAL
        return TRUTH

# Função para atualizar a matriz
def update_state(state_matrix):
    new_state_matrix = state_matrix.copy()
    for i in range(1, state_matrix.shape[0] - 1):
        for j in range(1, state_matrix.shape[1] - 1):
            new_state_matrix[i, j] = update_cell(i, j, state_matrix)
    return new_state_matrix

# Vetores para armazenar as populações
fake_pop = np.zeros(200)
neutral_pop = np.zeros(200)
truth_pop = np.zeros(200)

# Simulação por 200 gerações
for generation in range(200):
    fake_pop[generation] = np.count_nonzero(state_matrix == FAKE)
    neutral_pop[generation] = np.count_nonzero(state_matrix == NEUTRAL)
    truth_pop[generation] = np.count_nonzero(state_matrix == TRUTH)

    # Atualizando o estado
    state_matrix = update_state(state_matrix)

# Plotando a evolução das populações
fig, ax = plt.subplots()
ax.plot(fake_pop, color="red", label="Fake")
ax.plot(neutral_pop, color="gray", label="Neutral")
ax.plot(truth_pop, color="green", label="Truth")

ax.set_title("Evolução das populações")
ax.set_xlabel("Geração")
ax.set_ylabel("População")
ax.legend()

plt.show()

# Estatísticas iniciais e finais
initial_neutral = neutral_pop[0] / (neutral_pop[0] + truth_pop[0] + fake_pop[0])
initial_truth = truth_pop[0] / (neutral_pop[0] + truth_pop[0] + fake_pop[0])
initial_fake = fake_pop[0] / (neutral_pop[0] + truth_pop[0] + fake_pop[0])

final_neutral = neutral_pop[-1] / (neutral_pop[-1] + truth_pop[-1] + fake_pop[-1])
final_truth = truth_pop[-1] / (neutral_pop[-1] + truth_pop[-1] + fake_pop[-1])
final_fake = fake_pop[-1] / (neutral_pop[-1] + truth_pop[-1] + fake_pop[-1])

print("Prontinho!")
print(f"neutral_pop: initial {neutral_pop[0]} | final {neutral_pop[-1]} | avg {np.mean(neutral_pop)}")
print(f"truth_pop: initial {truth_pop[0]} | final {truth_pop[-1]} | avg {np.mean(truth_pop)}")
print(f"fake_pop: initial {fake_pop[0]} | final {fake_pop[-1]} | avg {np.mean(fake_pop)}")

# Plotando as populações iniciais e finais em gráficos de pizza
mycolors = ["gray", "green", "red"]
mylabels = ["Neutral", "Truth", "Fake"]
myexplode = [0.05, 0.05, 0.05]

# Populações iniciais
y = np.array([initial_neutral, initial_truth, initial_fake])
plt.title("Populações iniciais")
plt.pie(y, labels=mylabels, startangle=90, explode=myexplode, shadow=True, autopct='%1.1f%%', colors=mycolors)
plt.show()

# Populações finais
y = np.array([final_neutral, final_truth, final_fake])
plt.title("Populações finais")
plt.pie(y, labels=mylabels, startangle=90, explode=myexplode, shadow=True, autopct='%1.1f%%', colors=mycolors)
plt.show()